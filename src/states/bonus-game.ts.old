import * as _ from 'lodash';
import Pacman from '../components/pacman';
import Ghost from '../components/ghost';

export default class BonusGameState extends Phaser.State {

    game: Phaser.Game = this.game;

    map: Phaser.Tilemap = null;
    layer: Phaser.TilemapLayer = null;

    dots: Phaser.Group = null;
    numDots: number = 0;
    totalDots: number = 0;
    pills: Phaser.Group = null;
    numPills: number = 0;
    score: number = 0;
    scoreText: Phaser.Text = null;
    overflowText: Phaser.Text = null;

    pacman: any = null;
    clyde: any = null;
    pinky: any = null;
    inky: any = null;
    blinky: any = null;
    isInkyOut: boolean = false;
    isClydeOut: boolean = false;
    ghosts: any = [];

    safetile: number = 14;
    gridsize: number = 16;
    threshold: number = 3;

    SPECIAL_TILES: any = [
        { x: 12, y: 11 },
        { x: 15, y: 11 },
        { x: 12, y: 23 },
        { x: 15, y: 23 }
    ];

    TIME_MODES: any = [
        { mode: "scatter", time: 7000 },
        { mode: "chase", time: 20000 },
        { mode: "scatter", time: 7000 },
        { mode: "chase", time: 20000 },
        { mode: "scatter", time: 5000 },
        { mode: "chase", time: 20000 },
        { mode: "scatter", time: 5000 },
        { mode: "chase", time: -1 }
    ];

    changeModeTimer: number = 0;
    remainingTime: number = 0;
    currentMode: number = 0;
    isPaused: boolean = false;
    FRIGHTENED_MODE_TIME: number = 7000;

    ORIGINAL_OVERFLOW_ERROR_ON: boolean = true;
    DEBUG_ON: boolean = false;
    debugText: Phaser.Text = null;
    debugPosition: any = null;

    KEY_COOLING_DOWN_TIME: number = 250;
    lastKeyPressed: number = 0;

    cursors: any = null;

    create() {
        this.map = this.add.tilemap('map');
        this.map.addTilesetImage('pacman-tiles', 'tiles');

        this.layer = this.map.createLayer('Pacman');

        this.dots = this.add.physicsGroup();
        this.numDots = this.map.createFromTiles(7, this.safetile, 'dot', this.layer, this.dots);
        this.totalDots = this.numDots;

        this.pills = this.add.physicsGroup();
        this.numPills = this.map.createFromTiles(40, this.safetile, 'pill', this.layer, this.pills);

        //  The dots will need to be offset by 6px to put them back in the middle of the grid
        this.dots.setAll('x', 6, false, false, 1);
        this.dots.setAll('y', 6, false, false, 1);

        //  Pacman should collide with everything except the safe tile
        this.map.setCollisionByExclusion([this.safetile], true, this.layer);

        // Our hero
        this.pacman = new Pacman(this, "pacman");

        // Score and debug texts
        this.scoreText = this.game.add.text(8, 272, "Score: " + this.score, { font: "16px", fill: "#fff" });
        this.debugText = this.game.add.text(375, 260, "", { font: "12px", fill: "#fff" });
        this.overflowText = this.game.add.text(375, 280, "", { font: "12px", fill: "#fff" });
        
        this.cursors = this.input.keyboard.createCursorKeys();
        this.cursors["d"] = this.input.keyboard.addKey(Phaser.Keyboard.D);
        this.cursors["b"] = this.input.keyboard.addKey(Phaser.Keyboard.B);

        this.changeModeTimer = this.time.time + this.TIME_MODES[this.currentMode].time;
        
        // Ghosts
        this.blinky = new Ghost(this, "ghosts", "blinky", { x:13, y:11 }, Phaser.RIGHT);
        this.pinky = new Ghost(this, "ghosts", "pinky", { x:15, y:14 }, Phaser.LEFT);
        this.inky = new Ghost(this, "ghosts", "inky", { x:14, y:14 }, Phaser.RIGHT);
        this.clyde = new Ghost(this, "ghosts", "clyde", { x:17, y:14 }, Phaser.LEFT);
        this.ghosts.push(this.clyde, this.pinky, this.inky, this.blinky);
        
        this.sendExitOrder(this.pinky);
    }

    checkKeys() {
        this.pacman.checkKeys(this.cursors);
        
        if (this.lastKeyPressed < this.time.time) {
            if (this.cursors.d.isDown) {
                this.DEBUG_ON = (this.DEBUG_ON) ? false : true;
                this.lastKeyPressed = this.time.time + this.KEY_COOLING_DOWN_TIME;
            }
            if (this.cursors.b.isDown) {
                this.ORIGINAL_OVERFLOW_ERROR_ON = this.ORIGINAL_OVERFLOW_ERROR_ON ? false : true;
                this.pinky.ORIGINAL_OVERFLOW_ERROR_ON = this.ORIGINAL_OVERFLOW_ERROR_ON;
            }
        }
    }

    checkMouse() {
        if (this.input.mousePointer.isDown) {            
            var math: any = this.game.math;
            var x = math.snapToFloor(Math.floor(this.input.x), this.gridsize) / this.gridsize;
            var y = math.snapToFloor(Math.floor(this.input.y), this.gridsize) / this.gridsize;
            this.debugPosition = new Phaser.Point(x * this.gridsize, y * this.gridsize);
            console.log(x, y);
        }
    }

    dogEatsDog(pacman, ghost) {
        if (this.isPaused) {
            this[ghost.name].mode = this[ghost.name].RETURNING_HOME;
            this[ghost.name].ghostDestination = new Phaser.Point(14 * this.gridsize, 14 * this.gridsize);
            this[ghost.name].resetSafeTiles();
            this.score += 10;
        } else {
            this.killPacman();
        }
    }

    getCurrentMode() {
        if (!this.isPaused) {
            if (this.TIME_MODES[this.currentMode].mode === "scatter") {
                return "scatter";
            } else {
                return "chase";
            }
        } else {
            return "random";
        }
    }

    gimeMeExitOrder(ghost) {
        this.game.time.events.add(Math.random() * 3000, this.sendExitOrder, this, ghost);
    }

    killPacman() {
        this.pacman.isDead = true;
        this.stopGhosts();
    }

    stopGhosts() {
        for (var i=0; i<this.ghosts.length; i++) {
            this.ghosts[i].mode = this.ghosts[i].STOP;
        }
    }

    update() {
        this.scoreText.text = "Score: " + this.score;
        if (this.DEBUG_ON) {
            this.debugText.text = "Debug ON";
        } else {
            this.debugText.text = "";
        }
        if (this.ORIGINAL_OVERFLOW_ERROR_ON) {
            this.overflowText.text = "Overflow ON";
        } else {
            this.overflowText.text = "";
        }
        
        if (!this.pacman.isDead) {
            for (var i=0; i<this.ghosts.length; i++) {
                if (this.ghosts[i].mode !== this.ghosts[i].RETURNING_HOME) {
                    this.physics.arcade.overlap(this.pacman.sprite, this.ghosts[i].ghost, this.dogEatsDog, null, this);
                }
            }
            
            if (this.totalDots - this.numDots > 30 && !this.isInkyOut) {
                this.isInkyOut = true;
                this.sendExitOrder(this.inky);
            }
            
            if (this.numDots < this.totalDots/3 && !this.isClydeOut) {
                this.isClydeOut = true;
                this.sendExitOrder(this.clyde);
            }
            
            if (this.changeModeTimer !== -1 && !this.isPaused && this.changeModeTimer < this.time.time) {
                this.currentMode++;
                if (this.TIME_MODES[this.currentMode].time == -1) {
                    this.changeModeTimer = -1;
                } else {
                    this.changeModeTimer = this.time.time + this.TIME_MODES[this.currentMode].time;
                }

                if (this.TIME_MODES[this.currentMode].mode === "chase") {
                    this.sendAttackOrder();
                } else {
                    this.sendScatterOrder();
                }
                console.log("new mode:", this.TIME_MODES[this.currentMode].mode, this.TIME_MODES[this.currentMode].time);
            }
            if (this.isPaused && this.changeModeTimer < this.time.time) {
                this.changeModeTimer = this.time.time + this.remainingTime;
                this.isPaused = false;
                if (this.TIME_MODES[this.currentMode].mode === "chase") {
                    this.sendAttackOrder();
                } else {
                    this.sendScatterOrder();
                }
                console.log("new mode:", this.TIME_MODES[this.currentMode].mode, this.TIME_MODES[this.currentMode].time);
            }
        }
        
        this.pacman.update();
		this.updateGhosts();
        
        this.checkKeys();
        this.checkMouse();
    }

    enterFrightenedMode() {
        for (var i=0; i<this.ghosts.length; i++) {
            this.ghosts[i].enterFrightenedMode();
        }
        if (!this.isPaused) {
            this.remainingTime = this.changeModeTimer - this.time.time;
        }
        this.changeModeTimer = this.time.time + this.FRIGHTENED_MODE_TIME;
        this.isPaused = true;
        console.log(this.remainingTime);
    }

    isSpecialTile(tile) {
        for (var q=0; q<this.SPECIAL_TILES.length; q++) {
            if (tile.x === this.SPECIAL_TILES[q].x && tile.y === this.SPECIAL_TILES[q].y) {
                return true;
            } 
        }
        return false;
    }

    updateGhosts() {
        for (var i=0; i<this.ghosts.length; i++) {
            this.ghosts[i].update();
        }
    }

    render() {
        if (this.DEBUG_ON) {
            for (var i=0; i<this.ghosts.length; i++) {
                var color = "rgba(0, 255, 255, 0.6)";
                switch (this.ghosts[i].name) {
                    case "blinky":
                        color = "rgba(255, 0, 0, 0.6";
                        break;
                    case "pinky":
                        color = "rgba(255, 105, 180, 0.6";
                        break;
                    case "clyde":
                        color = "rgba(255, 165, 0, 0.6";
                        break;
                }
                if (this.ghosts[i].ghostDestination) {
                    var math: any = this.game.math;
                    var x = math.snapToFloor(Math.floor(this.ghosts[i].ghostDestination.x), this.gridsize);
                    var y = math.snapToFloor(Math.floor(this.ghosts[i].ghostDestination.y), this.gridsize);
                    this.game.debug.geom(new Phaser.Rectangle(x, y, 16, 16), color);
                }
            }
            if (this.debugPosition) {
                this.game.debug.geom(new Phaser.Rectangle(this.debugPosition.x, this.debugPosition.y, 16, 16), "#00ff00");
            }
        } else {
            this.game.debug.reset();
        }
    }

    sendAttackOrder() {
        for (var i=0; i<this.ghosts.length; i++) {
            this.ghosts[i].attack();
        }
    }

    sendExitOrder(ghost) {
        ghost.mode = this.clyde.EXIT_HOME;
    }

    sendScatterOrder() {
        for (var i=0; i<this.ghosts.length; i++) {
            this.ghosts[i].scatter();
        }
    }
}