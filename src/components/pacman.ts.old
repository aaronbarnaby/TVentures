import BonusGameState from "../states/bonus-game";

export default class Pacman {
    
    state: BonusGameState = null;
    key: string = null;
    
    speed = 100;
    isDead = false;
    isAnimatingDeath = false;
    
    gridsize: number = null;
    safetile: number = null;
    
    marker = new Phaser.Point();
    turnPoint = new Phaser.Point();
    threshold = 6;
    
    directions = [ null, null, null, null, null ];
    opposites = [ Phaser.NONE, Phaser.RIGHT, Phaser.LEFT, Phaser.DOWN, Phaser.UP ];
    
    current = Phaser.NONE;
    turning = Phaser.NONE;
    want2go = Phaser.NONE;
    
    keyPressTimer = 0;
    KEY_COOLING_DOWN_TIME = 750;
    
    sprite: Phaser.Sprite = null;
    
    constructor(state: BonusGameState, key: string) {
        this.state = state;
        this.key = key;
        
        this.gridsize = this.state.gridsize;
        this.safetile = this.state.safetile;
        
        this.sprite = this.state.add.sprite((14 * 16) + 8, (17 * 16) + 8, key, 0);
        this.sprite.anchor.setTo(0.5);
        this.sprite.animations.add('munch', [0, 1, 2, 1], 10, true);
        this.sprite.animations.add('death', [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], 10, false);
        
        this.state.physics.arcade.enable(this.sprite);
        this.sprite.body.setSize(20, 20, 0, 0);
        
        this.sprite.play('munch');
        this.move(Phaser.LEFT);
    }
    
    move(direction) {
        if (direction === Phaser.NONE) {
            this.sprite.body.velocity.x = this.sprite.body.velocity.y = 0;
            return;
        }
        
        var speed = this.speed;
        
        if (direction === Phaser.LEFT || direction === Phaser.UP) {
            speed = -speed;
        }
        
        if (direction === Phaser.LEFT || direction === Phaser.RIGHT) {
            this.sprite.body.velocity.x = speed;
        } else {
            this.sprite.body.velocity.y = speed;
        }
        
        // Reset the scale and angle
        this.sprite.scale.x = 1;
        this.sprite.angle = 0;
        
        if (direction === Phaser.LEFT) {
            this.sprite.scale.x = -1;
        } else if (direction === Phaser.UP) {
            this.sprite.angle = 270;
        } else if (direction === Phaser.DOWN) {
            this.sprite.angle = 90;
        }
        
        this.current = direction;
    }
    
    update() {
        if (!this.isDead) {
            this.state.physics.arcade.collide(this.sprite, this.state.layer);
            this.state.physics.arcade.overlap(this.sprite, this.state.dots, this.eatDot, null, this);
            this.state.physics.arcade.overlap(this.sprite, this.state.pills, this.eatPill, null, this);
            
            var math: any = this.state.game.math;
            this.marker.x = math.snapToFloor(Math.floor(this.sprite.x), this.gridsize) / this.gridsize;
            this.marker.y = math.snapToFloor(Math.floor(this.sprite.y), this.gridsize) / this.gridsize;
            
            if (this.marker.x < 0) {
                this.sprite.x = this.state.map.widthInPixels - 1;
            }
            
            if (this.marker.x >= this.state.map.width) {
                this.sprite.x = 1;
            }
            
            //  Update our grid sensors
            this.directions[1] = this.state.map.getTileLeft(this.state.layer.index, this.marker.x, this.marker.y);
            this.directions[2] = this.state.map.getTileRight(this.state.layer.index, this.marker.x, this.marker.y);
            this.directions[3] = this.state.map.getTileAbove(this.state.layer.index, this.marker.x, this.marker.y);
            this.directions[4] = this.state.map.getTileBelow(this.state.layer.index, this.marker.x, this.marker.y);
            
            if (this.turning !== Phaser.NONE) {
                this.turn();
            }
        } else {
            this.move(Phaser.NONE);
            if (!this.isAnimatingDeath) {
                this.sprite.play('death');
                this.isAnimatingDeath = true;
            }
        }
    }
    
    checkKeys(cursors) {
        if (cursors.left.isDown ||
            cursors.right.isDown ||
            cursors.up.isDown ||
            cursors.down.isDown) {
            this.keyPressTimer = this.state.time.time + this.KEY_COOLING_DOWN_TIME;
        }
    
        if (cursors.left.isDown && this.current !== Phaser.LEFT) {
            this.want2go = Phaser.LEFT;
        } else if (cursors.right.isDown && this.current !== Phaser.RIGHT) {
            this.want2go = Phaser.RIGHT;
        } else if (cursors.up.isDown && this.current !== Phaser.UP) {
            this.want2go = Phaser.UP;
        } else if (cursors.down.isDown && this.current !== Phaser.DOWN) {
            this.want2go = Phaser.DOWN;
        }
    
        if (this.state.time.time > this.keyPressTimer) {
            //  This forces them to hold the key down to turn the corner
            this.turning = Phaser.NONE;
            this.want2go = Phaser.NONE;
        } else {
            this.checkDirection(this.want2go);    
        }
    }
    
    eatDot(pacman, dot) {
        dot.kill();
    
        this.state.score ++;
        this.state.numDots --;

        if (this.state.dots.total === 0)
        {
            this.state.dots.callAll('revive', this);
        }
    }
    
    eatPill(pacman, pill) {
        pill.kill();
        
        this.state.score ++;
        this.state.numPills --;
        
        this.state.enterFrightenedMode();
    }
    
    turn() {
        var cx = Math.floor(this.sprite.x);
        var cy = Math.floor(this.sprite.y);
        
        //  This needs a threshold, because at high speeds you can't turn because the coordinates skip past
        var math: any = this.state.game.math;
        if (!math.fuzzyEqual(cx, this.turnPoint.x, this.threshold) || !math.fuzzyEqual(cy, this.turnPoint.y, this.threshold))
        {
            return false;
        }
        
        //  Grid align before turning
        this.sprite.x = this.turnPoint.x;
        this.sprite.y = this.turnPoint.y;
        
        this.sprite.body.reset(this.turnPoint.x, this.turnPoint.y);
        this.move(this.turning);
        this.turning = Phaser.NONE;
        
        return true;
    }
    
    checkDirection(turnTo) {
        if (this.turning === turnTo || (this.directions[turnTo] && this.directions[turnTo].index !== this.safetile))
        {
            //  Invalid direction if they're already set to turn that way
            //  Or there is no tile there, or the tile isn't index 1 (a floor tile)
            return;
        }
        
        //  Check if they want to turn around and can
        if (this.current === this.opposites[turnTo])
        {
            this.move(turnTo);
            this.keyPressTimer = this.state.time.time;
        }
        else
        {
            this.turning = turnTo;
            
            this.turnPoint.x = (this.marker.x * this.gridsize) + (this.gridsize / 2);
            this.turnPoint.y = (this.marker.y * this.gridsize) + (this.gridsize / 2);
            this.want2go = Phaser.NONE;
        }
    }
    
    getPosition() {
        return new Phaser.Point((this.marker.x * this.gridsize) + (this.gridsize / 2), (this.marker.y * this.gridsize) + (this.gridsize / 2));
    }
    
    getcurrentDirection() {
        return this.current;
    }
    
}